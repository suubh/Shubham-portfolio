"use strict";

exports.__esModule = true;
exports.setupInMemoryStore = setupInMemoryStore;

var _redux = require("../../redux");

/**
 * @deprecated
 */
function getNodes() {
  const nodes = _redux.store.getState().nodes;

  if (nodes) {
    return Array.from(nodes.values());
  } else {
    return [];
  }
}
/**
 * @deprecated
 */


function getNodesByType(type) {
  const nodes = _redux.store.getState().nodesByType.get(type);

  if (nodes) {
    return Array.from(nodes.values());
  } else {
    return [];
  }
}

function getNode(id) {
  return _redux.store.getState().nodes.get(id);
}

function getTypes() {
  // Note: sorting to match the output of the LMDB version (where keys are sorted by default)
  return Array.from(_redux.store.getState().nodesByType.keys()).sort();
}

function countNodes(typeName) {
  if (!typeName) {
    return _redux.store.getState().nodes.size;
  }

  const nodes = _redux.store.getState().nodesByType.get(typeName);

  return nodes ? nodes.size : 0;
}

const readyPromise = Promise.resolve(undefined);
/**
 * Returns promise that resolves when the store is ready for reads
 * (the in-memory store is always ready)
 */

function ready() {
  return readyPromise;
}

function setupInMemoryStore() {
  return {
    getNode,
    getTypes,
    countNodes,
    ready,
    // deprecated:
    getNodes,
    getNodesByType
  };
}
//# sourceMappingURL=in-memory-datastore.js.map